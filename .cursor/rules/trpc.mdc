---
description: 
globs: 
alwaysApply: true
---
# tRPC

- Use tRPC with tanstack react-query for all data fetching and mutation

## Data Fetching

### Server Side
- Server components should use the tRPC client and getQueryClient located at [server.tsx](mdc:src/lib/trpc/server.tsx) to prefetch the data.
- Server side data prefetching:

  ```typescript
  import { dehydrate, HydrationBoundary } from "@tanstack/react-query";
  import { headers } from "next/headers";
  import { redirect } from "next/navigation";
  import { Suspense } from "react";
  import { ErrorBoundary } from "react-error-boundary";

  import { auth } from "@/lib/auth";
  import {
    MealPlansView,
    MealPlansViewError,
    MealPlansViewSkeleton,
  } from "@/modules/meal-plans/ui/views/meal-plans-view";
  import { getQueryClient, trpc } from "@/lib/trpc/server";

  export default async function MealPlansPage() {
    const session = await auth.api.getSession({
      headers: await headers(),
    });

    if (!session) {
      redirect("/auth/sign-in");
    }

      if (!session.user.onboardingComplete) {
        return redirect("/onboarding");
      }

    const queryClient = getQueryClient();
    void queryClient.prefetchQuery(
      trpc.mealPlans.getMany.queryOptions()
    );

    return (
      <HydrationBoundary state={dehydrate(queryClient)}>
        <Suspense fallback={<MealPlansViewSkeleton />}>
          <ErrorBoundary fallback={<MealPlansViewError />}>
            <MealPlansView />
          </ErrorBoundary>
        </Suspense>
      </HydrationBoundary>
    );
  }
  ```

### Client Side
- Client components should use the useTRPC hook located at [client.tsx](mdc:src/lib/trpc/client.tsx) for data fetching.
- Client side data fetching:

  ```typescript
  "use client";

  import { useSuspenseQuery } from "@tanstack/react-query";
  import { useRouter } from "next/navigation";

  import { EmptyState } from "@/components/empty-state";
  import { ErrorState } from "@/components/error-state";
  import { Skeleton } from "@/components/ui/skeleton";
  import { useTRPC } from "@/lib/trpc/client";

  export function MealPlansView() {
    const trpc = useTRPC();
    const { data } = useSuspenseQuery(
      trpc.mealPlans.getMany.queryOptions()
    );

    return (
      <div className="flex-1 pb-4 px-4 md:px-8 flex flex-col gap-y-4">
        {data.items.length > 0 ? (
          <>
            <MealPlansGrid mealPlans={data.items} userId={session.user.id} />
            <Pagination onPageChange={(page) => setFilters({ page })} page={filters.page} totalPages={data.totalPages} />
          </>
        ) : (
          <EmptyState
            description="Try adjusting your search or filter criteria to find what you're looking for."
            icon={<IconAppsFilled className="size-8" />}
            title="No meal plans found"
          />
        )}
      </div>
    );
  }

  export function MealPlansViewSkeleton() {
    return (
      <div>
        <Skeleton className="h-4 w-16" />
        <Skeleton className="h-4 w-full" />
        <Skeleton className="h-4 w-full" />
      </div>
    );
  }

  export function MealPlansViewError() {
    return (
      <ErrorState
        title="Error loading meal plans"
        description="Something went wrong"
      />
    );
  }

  ```

## Data Mutation
- Use the useTRPC hook located at [client.tsx](mdc:src/lib/trpc/client.tsx) for data mutation:

  ```typescript
  "use client";

  import { zodResolver } from "@hookform/resolvers/zod";
  import { useMutation, useQueryClient } from "@tanstack/react-query";
  import { useForm } from "react-hook-form";
  import { toast } from "sonner";
  import { z } from "zod";

  import { Button } from "@/components/ui/button";
  import {
    Form,
    FormControl,
    FormField,
    FormItem,
    FormLabel,
    FormMessage,
  } from "@/components/ui/form";
  import { Input } from "@/components/ui/input";
  import { Textarea } from "@/components/ui/textarea";
  import { useTRPC } from "@/lib/trpc/client";
  import { recipesInsertSchema } from "../../schemas";
  import { RecipeGetOne } from "../../types";

  interface RecipeFormProps {
    onSuccess?: () => void;
    initialValues?: RecipeGetOne;
  }

  export function RecipeForm({
    onSuccess,
    initialValues,
  }: RecipeFormProps) {
    const trpc = useTRPC();
    const queryClient = useQueryClient();

    const createRecipe = useMutation(
      trpc.recipes.create.mutationOptions({
        onSuccess: async () => {
          await queryClient.invalidateQueries(
            trpc.recipes.getMany.queryOptions({})
          );

          onSuccess?.();
        },
        onError: (error) => {
          toast.error(error.message);
        },
      })
    );

    const updateRecipe = useMutation(
      trpc.recipes.update.mutationOptions({
        onSuccess: async () => {
          await queryClient.invalidateQueries(
            trpc.recipes.getMany.queryOptions({})
          );

          if (initialValues?.id) {
            await queryClient.invalidateQueries(
              trpc.recipes.getOne.queryOptions({
                id: initialValues.id,
              })
            );
          }

          onSuccess?.();
        },
        onError: (error) => {
          toast.error(error.message);
        },
      })
    );

    const form = useForm<z.infer<typeof recipesInsertSchema>>({
      resolver: zodResolver(recipesInsertSchema),
      defaultValues: {
        name: initialValues?.name ?? "",
        instructions: initialValues?.instructions ?? "",
      },
    });

    const isEdit = !!initialValues?.id;
    const isLoading = createRecipe.isPending || updateRecipe.isPending;

    const onSubmit = (values: z.infer<typeof recipesInsertSchema>) => {
      if (isEdit) {
        updateRecipe.mutate({ ...values, id: initialValues.id });
      } else {
        createRecipe.mutate(values);
      }
    };

    return (
      <Form {...form}>
        <form className="space-y-4" onSubmit={form.handleSubmit(onSubmit)}>
          <FormField
            name="name"
            control={form.control}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Name</FormLabel>
                <FormControl>
                  <Input {...field} placeholder="e.g. Tacos" />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <FormField
            name="instructions"
            control={form.control}
            render={({ field }) => (
              <FormItem>
                <FormLabel>Instructions</FormLabel>
                <FormControl>
                  <Textarea
                    {...field}
                    placeholder="e.g. 1. Fry minced beef"
                  />
                </FormControl>
                <FormMessage />
              </FormItem>
            )}
          />
          <Button isLoading={isLoading} disabled={isLoading} type="submit">
            {isEdit ? "Update" : "Create"}
          </Button>
        </form>
      </Form>
    );
  }

  ```

## Procedures
- Use the public, protected, or premium procedures located at [init.ts](mdc:src/lib/trpc/init.ts) for authorization

### Format
- Create tRPC procedures in the following format:

  ```typescript
  import { z } from "zod";

  import { DEFAULT_PAGE, DEFAULT_PAGE_SIZE } from "@/lib/constants";
  import { createTRPCRouter, protectedProcedure } from "@/lib/trpc/init";
  import { createRecipeSchema, recipeFiltersSchema, scrapeRecipeSchema, updateRecipeSchema } from "../schemas";
  import * as recipesService from "./recipes-service";

  export const recipesRouter = createTRPCRouter({
    create: protectedProcedure.input(createRecipeSchema).mutation(async ({ ctx, input }) => {
      return await recipesService.createRecipe(ctx.auth.user.id, input);
    }),
    update: protectedProcedure.input(updateRecipeSchema).mutation(async ({ ctx, input }) => {
      const { id, ...data } = input;
      return await recipesService.updateRecipe(id, ctx.auth.user.id, data);
    }),
    getOne: protectedProcedure.input(z.object({ id: z.number() })).query(async ({ ctx, input }) => {
      const userId = ctx.auth.user.id;
      return await recipesService.getRecipe(input.id, userId);
    }),
    getMany: protectedProcedure.input(recipeFiltersSchema.optional()).query(async ({ ctx, input }) => {
      return await recipesService.getRecipes(
        ctx.auth.user.id,
        input || {
          page: DEFAULT_PAGE,
          pageSize: DEFAULT_PAGE_SIZE,
          sortBy: "default",
          sortOrder: "desc",
        }
      );
    }),
    delete: protectedProcedure.input(z.object({ id: z.number() })).mutation(async ({ ctx, input }) => {
      return await recipesService.deleteRecipe(input.id, ctx.auth.user.id);
    }),
  });


  ```

## Types
- For types that will be used based on the data fetching results, infer them based on the procedures in a types.ts file in the module e.g. `@/modules/foods/types.ts`

  ```typescript
  import { inferRouterOutputs } from "@trpc/server";

  import type { AppRouter } from "@/lib/trpc/routers/_app";

  export type FoodGetOne = inferRouterOutputs<AppRouter>["foods"]["getOne"];
  export type FoodGetMany =
    inferRouterOutputs<AppRouter>["foods"]["getMany"]["items"];

  ```